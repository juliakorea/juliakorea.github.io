<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>함수 · 줄리아 언어</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-110655381-2', 'auto');
ga('send', 'pageview', {'page': location.pathname + location.search + location.hash});
</script><link rel="canonical" href="https://juliakorea.github.io/ko/latest/manual/functions/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="줄리아 언어 logo"/></a><div class="docs-package-name"><span class="docs-autofit">줄리아 언어</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">줄리아 문서</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">매뉴얼</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../getting-started/">시작하기</a></li><li><a class="tocitem" href="../variables/">변수</a></li><li><a class="tocitem" href="../integers-and-floating-point-numbers/">정수와 부동 소수점 수</a></li><li><a class="tocitem" href="../mathematical-operations/">산술 연산과 기본 함수</a></li><li><a class="tocitem" href="../complex-and-rational-numbers/">복소수와 유리수</a></li><li><a class="tocitem" href="../strings/">Strings</a></li><li class="is-active"><a class="tocitem" href>함수</a><ul class="internal"><li><a class="tocitem" href="#인자-전달-방식-1"><span>인자 전달 방식</span></a></li><li><a class="tocitem" href="#return-키워드-1"><span>return 키워드</span></a></li><li><a class="tocitem" href="#반환-타입-1"><span>반환 타입</span></a></li><li><a class="tocitem" href="#반환값이-없는-함수-1"><span>반환값이 없는 함수</span></a></li><li><a class="tocitem" href="#연산자는-함수다-1"><span>연산자는 함수다</span></a></li><li><a class="tocitem" href="#특별한-이름을-가진-함수-1"><span>특별한 이름을 가진 함수</span></a></li><li><a class="tocitem" href="#man-anonymous-functions-1"><span>익명 함수</span></a></li><li><a class="tocitem" href="#튜플-1"><span>튜플</span></a></li><li><a class="tocitem" href="#지명-튜플(Named-tuple)-1"><span>지명 튜플(Named tuple)</span></a></li><li><a class="tocitem" href="#다중-반환-1"><span>다중 반환</span></a></li><li><a class="tocitem" href="#인자-분리-1"><span>인자 분리</span></a></li><li><a class="tocitem" href="#가변인자-함수-1"><span>가변인자 함수</span></a></li><li><a class="tocitem" href="#기본값이-제공된-인자(optional-arguments)-1"><span>기본값이 제공된 인자(optional arguments)</span></a></li><li><a class="tocitem" href="#Keyword-Arguments-1"><span>Keyword Arguments</span></a></li><li><a class="tocitem" href="#Evaluation-Scope-of-Default-Values-1"><span>Evaluation Scope of Default Values</span></a></li><li><a class="tocitem" href="#Do-Block-Syntax-for-Function-Arguments-1"><span>Do-Block Syntax for Function Arguments</span></a></li><li><a class="tocitem" href="#Function-composition-and-piping-1"><span>Function composition and piping</span></a></li><li><a class="tocitem" href="#man-vectorized-1"><span>배열에서 사용하는 Dot 문법</span></a></li><li><a class="tocitem" href="#Further-Reading-1"><span>Further Reading</span></a></li></ul></li><li><a class="tocitem" href="../control-flow/">제어 흐름</a></li><li><a class="tocitem" href="../variables-and-scoping/">Scope of Variables</a></li><li><a class="tocitem" href="../types/">Types</a></li><li><a class="tocitem" href="../methods/">메서드</a></li><li><a class="tocitem" href="../constructors/">Constructors</a></li><li><a class="tocitem" href="../conversion-and-promotion/">Conversion and Promotion</a></li><li><a class="tocitem" href="../interfaces/">Interfaces</a></li><li><a class="tocitem" href="../modules/">Modules</a></li><li><a class="tocitem" href="../documentation/">Documentation</a></li><li><a class="tocitem" href="../metaprogramming/">Metaprogramming</a></li><li><a class="tocitem" href="../arrays/">다차원 배열</a></li><li><a class="tocitem" href="../missing/">Missing Values</a></li><li><a class="tocitem" href="../networking-and-streams/">Networking and Streams</a></li><li><a class="tocitem" href="../parallel-computing/">Parallel Computing</a></li><li><a class="tocitem" href="../asynchronous-programming/">Asynchronous Programming</a></li><li><a class="tocitem" href="../multi-threading/">Multi-Threading</a></li><li><a class="tocitem" href="../distributed-computing/">Multi-processing and Distributed Computing</a></li><li><a class="tocitem" href="../running-external-programs/">Running External Programs</a></li><li><a class="tocitem" href="../calling-c-and-fortran-code/">Calling C and Fortran Code</a></li><li><a class="tocitem" href="../handling-operating-system-variation/">운영체제 변수 다루기</a></li><li><a class="tocitem" href="../environment-variables/">Environment Variables</a></li><li><a class="tocitem" href="../embedding/">Embedding Julia</a></li><li><a class="tocitem" href="../code-loading/">Code Loading</a></li><li><a class="tocitem" href="../profile/">Profiling</a></li><li><a class="tocitem" href="../stacktraces/">Stack Traces</a></li><li><a class="tocitem" href="../performance-tips/">Performance Tips</a></li><li><a class="tocitem" href="../workflow-tips/">Workflow Tips</a></li><li><a class="tocitem" href="../style-guide/">Style Guide</a></li><li><a class="tocitem" href="../faq/">Frequently Asked Questions</a></li><li><a class="tocitem" href="../noteworthy-differences/">Noteworthy Differences from other Languages</a></li><li><a class="tocitem" href="../unicode-input/">Unicode Input</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Base</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../base/base/">기본 골자</a></li><li><a class="tocitem" href="../../base/collections/">Collections and Data Structures</a></li><li><a class="tocitem" href="../../base/math/">Mathematics</a></li><li><a class="tocitem" href="../../base/numbers/">Numbers</a></li><li><a class="tocitem" href="../../base/strings/">Strings</a></li><li><a class="tocitem" href="../../base/arrays/">Arrays</a></li><li><a class="tocitem" href="../../base/parallel/">Tasks</a></li><li><a class="tocitem" href="../../base/multi-threading/">Multi-Threading</a></li><li><a class="tocitem" href="../../base/constants/">Constants</a></li><li><a class="tocitem" href="../../base/file/">Filesystem</a></li><li><a class="tocitem" href="../../base/io-network/">I/O and Network</a></li><li><a class="tocitem" href="../../base/punctuation/">Punctuation</a></li><li><a class="tocitem" href="../../base/sort/">Sorting and Related Functions</a></li><li><a class="tocitem" href="../../base/iterators/">Iteration utilities</a></li><li><a class="tocitem" href="../../base/c/">C Interface</a></li><li><a class="tocitem" href="../../base/libc/">C Standard Library</a></li><li><a class="tocitem" href="../../base/stacktraces/">StackTraces</a></li><li><a class="tocitem" href="../../base/simd-types/">SIMD Support</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">표준 라이브러리</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../stdlib/Base64/">Base64</a></li><li><a class="tocitem" href="../../stdlib/CRC32c/">CRC32c</a></li><li><a class="tocitem" href="../../stdlib/Dates/">Dates</a></li><li><a class="tocitem" href="../../stdlib/DelimitedFiles/">Delimited Files</a></li><li><a class="tocitem" href="../../stdlib/Distributed/">Distributed Computing</a></li><li><a class="tocitem" href="../../stdlib/FileWatching/">File Events</a></li><li><a class="tocitem" href="../../stdlib/Future/">Future</a></li><li><a class="tocitem" href="../../stdlib/InteractiveUtils/">Interactive Utilities</a></li><li><a class="tocitem" href="../../stdlib/LibGit2/">LibGit2</a></li><li><a class="tocitem" href="../../stdlib/Libdl/">Dynamic Linker</a></li><li><a class="tocitem" href="../../stdlib/LinearAlgebra/">Linear Algebra</a></li><li><a class="tocitem" href="../../stdlib/Logging/">Logging</a></li><li><a class="tocitem" href="../../stdlib/Markdown/">Markdown</a></li><li><a class="tocitem" href="../../stdlib/Mmap/">Memory-mapped I/O</a></li><li><a class="tocitem" href="../../stdlib/Pkg/">Pkg</a></li><li><a class="tocitem" href="../../stdlib/Printf/">Printf</a></li><li><a class="tocitem" href="../../stdlib/Profile/">Profiling</a></li><li><a class="tocitem" href="../../stdlib/REPL/">The Julia REPL</a></li><li><a class="tocitem" href="../../stdlib/Random/">Random Numbers</a></li><li><a class="tocitem" href="../../stdlib/SHA/">SHA</a></li><li><a class="tocitem" href="../../stdlib/Serialization/">Serialization</a></li><li><a class="tocitem" href="../../stdlib/SharedArrays/">Shared Arrays</a></li><li><a class="tocitem" href="../../stdlib/Sockets/">Sockets</a></li><li><a class="tocitem" href="../../stdlib/SparseArrays/">Sparse Arrays</a></li><li><a class="tocitem" href="../../stdlib/Statistics/">Statistics</a></li><li><a class="tocitem" href="../../stdlib/Test/">Unit Testing</a></li><li><a class="tocitem" href="../../stdlib/UUIDs/">UUIDs</a></li><li><a class="tocitem" href="../../stdlib/Unicode/">Unicode</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">개발자 문서</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../devdocs/reflection/">Reflection and introspection</a></li><li><input class="collapse-toggle" id="menuitem-6-2" type="checkbox"/><label class="tocitem" for="menuitem-6-2"><span class="docs-label">Documentation of Julia&#39;s Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../devdocs/init/">Initialization of the Julia runtime</a></li><li><a class="tocitem" href="../../devdocs/ast/">Julia ASTs</a></li><li><a class="tocitem" href="../../devdocs/types/">More about types</a></li><li><a class="tocitem" href="../../devdocs/object/">Memory layout of Julia Objects</a></li><li><a class="tocitem" href="../../devdocs/eval/">Eval of Julia code</a></li><li><a class="tocitem" href="../../devdocs/callconv/">Calling Conventions</a></li><li><a class="tocitem" href="../../devdocs/compiler/">High-level Overview of the Native-Code Generation Process</a></li><li><a class="tocitem" href="../../devdocs/functions/">Julia Functions</a></li><li><a class="tocitem" href="../../devdocs/cartesian/">Base.Cartesian</a></li><li><a class="tocitem" href="../../devdocs/meta/">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="tocitem" href="../../devdocs/subarrays/">SubArrays</a></li><li><a class="tocitem" href="../../devdocs/isbitsunionarrays/">isbits Union Optimizations</a></li><li><a class="tocitem" href="../../devdocs/sysimg/">System Image Building</a></li><li><a class="tocitem" href="../../devdocs/llvm/">Working with LLVM</a></li><li><a class="tocitem" href="../../devdocs/stdio/">printf() and stdio in the Julia runtime</a></li><li><a class="tocitem" href="../../devdocs/boundscheck/">Bounds checking</a></li><li><a class="tocitem" href="../../devdocs/locks/">Proper maintenance and care of multi-threading locks</a></li><li><a class="tocitem" href="../../devdocs/offset-arrays/">Arrays with custom indices</a></li><li><a class="tocitem" href="../../devdocs/require/">Module loading</a></li><li><a class="tocitem" href="../../devdocs/inference/">Inference</a></li><li><a class="tocitem" href="../../devdocs/ssair/">Julia SSA-form IR</a></li><li><a class="tocitem" href="../../devdocs/gc-sa/">Static analyzer annotations for GC correctness in C code</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-3" type="checkbox"/><label class="tocitem" for="menuitem-6-3"><span class="docs-label">Developing/debugging Julia&#39;s C code</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../devdocs/backtraces/">Reporting and analyzing crashes (segfaults)</a></li><li><a class="tocitem" href="../../devdocs/debuggingtips/">gdb debugging tips</a></li><li><a class="tocitem" href="../../devdocs/valgrind/">Using Valgrind with Julia</a></li><li><a class="tocitem" href="../../devdocs/sanitizers/">Sanitizer support</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">매뉴얼</a></li><li class="is-active"><a href>함수</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>함수</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/juliakorea/translate-doc/blob/master/src/manual/functions.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="man-functions-1"><a class="docs-heading-anchor" href="#man-functions-1">함수</a><a class="docs-heading-anchor-permalink" href="#man-functions-1" title="Permalink"></a></h1><p>함수는 인자를 받아 값을 반환하는 객체이다. Julia에서 정의하는 함수는 실행 상황에 영향을 받는다는 점에서 수학적 정의에 따른 함수와는 조금 다르다. 아래는 Julia에서 함수를 정의하는 가장 기본적인 방법이다:</p><pre><code class="language-julia-repl">julia&gt; function f(x,y)
           x + y
       end
f (generic function with 1 method)</code></pre><p>아래와 같이 함수를 정의하는 방법도 있다:</p><pre><code class="language-julia-repl">julia&gt; f(x,y) = x + y
f (generic function with 1 method)</code></pre><p>위처럼 &quot;할당 형식(assignment form)&quot;으로 선언할 경우 복합 표현이더라도 한 줄로 표현해야 한다(<a href="../control-flow/#man-compound-expressions-1">복합 표현을 자세하고 알고 싶다면?</a>). 이렇게 함수를 표현하는 경우는 Julia에 흔한 일이고, 때론 코드 가독성을 높여준다.</p><p>다른 언어처럼 소괄호를 통해 함수 인자를 전달한다:</p><pre><code class="language-julia-repl">julia&gt; f(2,3)
5</code></pre><p>소괄호가 없는 <code>f</code>는 함수 객체로써 하나의 값으로 취급할 수 있다:</p><pre><code class="language-julia-repl">julia&gt; g = f;

julia&gt; g(2,3)
5</code></pre><p>함수의 이름은 유니코드라면 무엇이든지 가능하다:</p><pre><code class="language-julia-repl">julia&gt; ∑(x,y) = x + y
∑ (generic function with 1 method)

julia&gt; ∑(2, 3)
5</code></pre><h2 id="인자-전달-방식-1"><a class="docs-heading-anchor" href="#인자-전달-방식-1">인자 전달 방식</a><a class="docs-heading-anchor-permalink" href="#인자-전달-방식-1" title="Permalink"></a></h2><p>함수에 인자를 줄 때 Julia는 &quot;공유를 통한 전달(<a href="https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing">pass-by-sharing</a>)&quot;을 한다. 이 말인즉슨, 객체를 복사하지 않고 공유한다는 뜻이다. 전달된 인자는 함수 안에 있는 변수에 할당되고, 함수 안의 변수는 단지 그 객체를 가리킬 뿐이다. <code>Array</code>와 같은 mutable 객체가 함수 안에서 변하면, 함수 밖에서도 그 변화를 볼 수 있다. 이런 방식은 Scheme, Python, Ruby, Perl 그리고 대부분의 Lisp와 같은 동적언어가 채택한 방식이다.</p><h2 id="return-키워드-1"><a class="docs-heading-anchor" href="#return-키워드-1">return 키워드</a><a class="docs-heading-anchor-permalink" href="#return-키워드-1" title="Permalink"></a></h2><p>함수가 반환하는 값은 암묵적으로 가장 마지막으로 계산된 값이다. 이전의 예제 함수 <code>f</code>에서는 <code>x+y</code>의 값이 반환될 것이다. 다른 프로그래밍 언어처럼 <code>return</code>과 반환값이 명시적으로 선언될 경우, 함수는 즉시 종료되고 <code>return</code> 앞에 있는 식을 계산하고 반환할 것이다:</p><pre><code class="language-julia">function g(x,y)
    return x * y
    x + y
end</code></pre><p>직접 테스트해보자:</p><pre><code class="language-julia-repl">julia&gt; f(x,y) = x + y
f (generic function with 1 method)

julia&gt; function g(x,y)
           return x * y
           x + y
       end
g (generic function with 1 method)

julia&gt; f(2,3)
5

julia&gt; g(2,3)
6</code></pre><p>함수 <code>g</code>에서 <code>x+y</code>는 절대 실행되지 않기 때문에, 이 부분을 빼고 <code>x*y</code>만 남겨놔도 똑같이 작동한다. <code>return</code>을 직접 선언하는 방식은 조건문과 같이 코드의 흐름을 바꾸는 구문과 사용했을 때 빛을 발한다. 아래에 직각 삼각형에서 밑변 <code>x</code>와 높이 <code>y</code>가 주어졌을 때 빗변의 길이는 구하는 예제로 확인할 수 있다. 아래 함수는 overflow를 없애기 위해 조건문을 사용했다:</p><pre><code class="language-julia-repl">julia&gt; function hypot(x,y)
           x = abs(x)
           y = abs(y)
           if x &gt; y
               r = y/x
               return x*sqrt(1+r*r)
           end
           if y == 0
               return zero(x)
           end
           r = x/y
           return y*sqrt(1+r*r)
       end
hypot (generic function with 1 method)

julia&gt; hypot(3, 4)
5.0</code></pre><p>위 함수는 경우에 따라 세 가지 방법으로 값을 반환한다. 마지막에 <code>return</code>은 생략해도 된다.</p><h2 id="반환-타입-1"><a class="docs-heading-anchor" href="#반환-타입-1">반환 타입</a><a class="docs-heading-anchor-permalink" href="#반환-타입-1" title="Permalink"></a></h2><p>반환값의 타입은 <code>::</code>로 명시할 수 있으며, 이 경우 반환값이 자동 형변환된다.</p><pre><code class="language-julia-repl">julia&gt; function g(x, y)::Int8
           return x * y
       end;

julia&gt; typeof(g(1, 2))
Int8</code></pre><p>위 함수는 <code>x</code>와 <code>y</code>의 타입에 상관없이 반환값은 <code>Int8</code>로 정해져있다. 타입에 대해 자세히 알고 싶다면 <a href="../types/#Type-Declarations-1">Type Declarations</a>을 참고하자.</p><h2 id="반환값이-없는-함수-1"><a class="docs-heading-anchor" href="#반환값이-없는-함수-1">반환값이 없는 함수</a><a class="docs-heading-anchor-permalink" href="#반환값이-없는-함수-1" title="Permalink"></a></h2><p>함수가 값을 반환할 필요가 없을 경우, Julia 언어 내에서는 관습적으로 <a href="manual/@ref">nothing</a>을 반환한다:</p><pre><code class="language-julia">function printx(x)
    println(&quot;x = $x&quot;)
    return nothing
end</code></pre><p>This is a <em>convention</em> in the sense that <code>nothing</code> is not a Julia keyword but a only singleton object of type <code>Nothing</code>. Also, you may notice that the <code>printx</code> function example above is contrived, because <code>println</code> already returns <code>nothing</code>, so that the <code>return</code> line is redundant.</p><p>There are two possible shortened forms for the <code>return nothing</code> expression. On the one hand, the <code>return</code> keyword implicitly returns <code>nothing</code>, so it can be used alone. On the other hand, since functions implicitly return their last expression evaluated, <code>nothing</code> can be used alone when it&#39;s the last expression. The preference for the expression <code>return nothing</code> as opposed to <code>return</code> or <code>nothing</code> alone is a matter of coding style.</p><h2 id="연산자는-함수다-1"><a class="docs-heading-anchor" href="#연산자는-함수다-1">연산자는 함수다</a><a class="docs-heading-anchor-permalink" href="#연산자는-함수다-1" title="Permalink"></a></h2><p>Julia에서 연산자는 특별한 문법을 가진 함수일 뿐이다(<code>&amp;&amp;</code>와 <code>||</code>는 예외다. 이들은 <a href="../control-flow/#Short-Circuit-Evaluation-1">단락 계산</a>에서 나왔다시피 연산자가 피연산자보다 먼저 계산되기 때문이다). 따라서 연산자는 일반 함수처럼 소괄호를 이용해 인자를 전달할 수 있다:</p><pre><code class="language-julia-repl">julia&gt; 1 + 2 + 3
6

julia&gt; +(1,2,3)
6</code></pre><p>infix 표기법(<code>1+2+3</code>)과 함수 표기법은 같은 결과를 낸다. 실제로 Julia는 내부에서 infix 표기를 함수 표기로 바꿔서 계산하기 때문에 같을 수밖에 없다. 연산자가 함수이기 때문에 다음과 같이 사용할 수도 있다:</p><pre><code class="language-julia-repl">julia&gt; f = +;

julia&gt; f(1,2,3)
6</code></pre><p>다만 위처럼 함수 이름이 바뀌면 infix 표기법을 사용할 수 없다.</p><h2 id="특별한-이름을-가진-함수-1"><a class="docs-heading-anchor" href="#특별한-이름을-가진-함수-1">특별한 이름을 가진 함수</a><a class="docs-heading-anchor-permalink" href="#특별한-이름을-가진-함수-1" title="Permalink"></a></h2><p>특정 함수는 호출 대신 특수한 문법으로 대체할 수 있다. 그러한 함수는 다음과 같습니다:</p><table><tr><th style="text-align: left">문법</th><th style="text-align: left">함수 이름</th></tr><tr><td style="text-align: left"><code>[A B C ...]</code></td><td style="text-align: left"><a href="../../base/arrays/#Base.hcat"><code>hcat</code></a></td></tr><tr><td style="text-align: left"><code>[A; B; C; ...]</code></td><td style="text-align: left"><a href="../../base/arrays/#Base.vcat"><code>vcat</code></a></td></tr><tr><td style="text-align: left"><code>[A B; C D; ...]</code></td><td style="text-align: left"><a href="../../base/arrays/#Base.hvcat"><code>hvcat</code></a></td></tr><tr><td style="text-align: left"><code>A&#39;</code></td><td style="text-align: left"><a href="../../stdlib/LinearAlgebra/#Base.adjoint"><code>adjoint</code></a></td></tr><tr><td style="text-align: left"><code>A[i]</code></td><td style="text-align: left"><a href="../../base/collections/#Base.getindex"><code>getindex</code></a></td></tr><tr><td style="text-align: left"><code>A[i] = x</code></td><td style="text-align: left"><a href="../../base/collections/#Base.setindex!"><code>setindex!</code></a></td></tr><tr><td style="text-align: left"><code>A.n</code></td><td style="text-align: left"><a href="../../base/base/#Base.getproperty"><code>getproperty</code></a></td></tr><tr><td style="text-align: left"><code>A.n = x</code></td><td style="text-align: left"><a href="../../base/base/#Base.setproperty!"><code>setproperty!</code></a></td></tr></table><h2 id="man-anonymous-functions-1"><a class="docs-heading-anchor" href="#man-anonymous-functions-1">익명 함수</a><a class="docs-heading-anchor-permalink" href="#man-anonymous-functions-1" title="Permalink"></a></h2><p>Julia에서 함수는 <a href="https://ko.wikipedia.org/wiki/%EC%9D%BC%EA%B8%89_%EA%B0%9D%EC%B2%B4">일급 객체</a>다: 변수에 값으로 저장될 수 있고, 해당 변수를 함수로 사용할 수 있다. 또 함수 객체는 다른 함수의 인자가 될 수도 있고 반환값이 될 수도 있다. 함수의 이름이 없어도 함수를 다음과 같은 방법으로 정의할 수 있다:</p><pre><code class="language-julia-repl">julia&gt; x -&gt; x^2 + 2x - 1
#1 (generic function with 1 method)

julia&gt; function (x)
           x^2 + 2x - 1
       end
#3 (generic function with 1 method)</code></pre><p>두 방법 모두 <code>x</code>를 받아 <code>x^2 + 2x - 1</code>를 반환하는 함수를 만든다. 위와 같은 방식으로 함수를 만들면 함수 이름 대신 컴파일러가 #1, #3과 같은 숫자로 함수를 구분하는 걸 볼 수 있다.</p><p>익명 함수는 함수를 함수 인자로 주면서, 한 번 밖에 사용하지 않을 때 유용하다. <a href="../../base/collections/#Base.map"><code>map</code></a>이 그 중 하나로, 배열이 값 각각을 인자로 받는 함수를 받아 반환값으로 새로운 배열을 만든다:</p><pre><code class="language-julia-repl">julia&gt; map(round, [1.2,3.5,1.7])
3-element Array{Float64,1}:
 1.0
 4.0
 2.0</code></pre><p>위에서는 이미 원하는 함수가 정의되어 있었기 때문에 문제가 없었다. 하지만 그런 함수가 없을 때, 익명 함수를 사용하면 편리하다:</p><pre><code class="language-julia-repl">julia&gt; map(x -&gt; x^2 + 2x - 1, [1,3,-1])
3-element Array{Int64,1}:
  2
 14
 -2</code></pre><p>익명 함수에 다중 인자를 사용하려면 <code>(x,y,z)-&gt;2x+y-z</code>처럼 쓰면 된다. <code>()-&gt;3</code>처럼 인자를 받지 않는 함수를 정의할 수도 있다. 처음 프로그래밍을 접하면 &quot;인자를 받지 않는 함수를 왜쓰지?&quot;라고 생각할 수 있지만 코딩을 하다보면 여러모로 유용하다.</p><h2 id="튜플-1"><a class="docs-heading-anchor" href="#튜플-1">튜플</a><a class="docs-heading-anchor-permalink" href="#튜플-1" title="Permalink"></a></h2><p>줄리아의 <em>튜플</em>은 함수의 입출력에 중요하게 관여한다. 튜플은 어떤 값이든 저장할 수 있는 고정 크기의 컨테이너이며, 생성 후에는 수정이 불가능(immutable)하다. 튜플은 반점과 소괄호를 이용해 만들고 인덱싱을 통해 값에 접근한다:</p><pre><code class="language-julia-repl">julia&gt; (1, 1+1)
(1, 2)

julia&gt; (1,)
(1,)

julia&gt; x = (0.0, &quot;hello&quot;, 6*7)
(0.0, &quot;hello&quot;, 42)

julia&gt; x[2]
&quot;hello&quot;</code></pre><p>크기가 1인 튜플을 만들고 싶어도 <code>(1,)</code>처럼 꼭 반점을 넣어야 한다. <code>(1)</code>은 값을 소괄호로 감싼 것으로 취급된다. <code>()</code>은 비어 있는 튜플을 생성한다.</p><h2 id="지명-튜플(Named-tuple)-1"><a class="docs-heading-anchor" href="#지명-튜플(Named-tuple)-1">지명 튜플(Named tuple)</a><a class="docs-heading-anchor-permalink" href="#지명-튜플(Named-tuple)-1" title="Permalink"></a></h2><p>튜플의 인자에 이름을 부여할 수 있으며 이를 <em>지명 튜플</em>이라고 한다:</p><pre><code class="language-julia-repl">julia&gt; x = (a=1, b=1+1)
(a = 1, b = 2)

julia&gt; x.a
1</code></pre><p>지명 튜플은 이름이 있다는 것을 제외하면 일반적인 튜플과 유사하며, dot 문법을 통해 값에 접근할 수 있다 (<code>x.a</code>).</p><h2 id="다중-반환-1"><a class="docs-heading-anchor" href="#다중-반환-1">다중 반환</a><a class="docs-heading-anchor-permalink" href="#다중-반환-1" title="Permalink"></a></h2><p>여러 값을 반환하기 위해 함수는 튜플을 반환한다. 하지만 튜플은 괄호 없이 생성되기도 하고 분리되기도 하므로 명시적으로 튜플을 사용한다는 것을 나타낼 필요가 없다. 이는 우리가 값을 여러 개 반환한다는 환상을 심어준다. 예제로 두 개의 값을 반환하는 상황을 보자:</p><pre><code class="language-julia-repl">julia&gt; function foo(a,b)
           a+b, a*b
       end
foo (generic function with 1 method)</code></pre><p>대화형 실행환경에서 함수를 실행하면 튜플이 반환되는 것을 확인할 수 있다:</p><pre><code class="language-julia-repl">julia&gt; foo(2,3)
(5, 6)</code></pre><p>보통의 경우 튜플의 값을 변수로 각각 분리하고 사용하기 때문에, Julia는 튜플을 분리할 수 있는 간단한 방법을 제공하여 편의성을 높였다:</p><pre><code class="language-julia-repl">julia&gt; x, y = foo(2,3)
(5, 6)

julia&gt; x
5

julia&gt; y
6</code></pre><p><code>return</code>으로도 다중 변수 반환을 할 수 있다. 아래 예제는 이전 예제와 똑같이 작동한다:</p><pre><code class="language-julia">function foo(a,b)
    return a+b, a*b
end</code></pre><h2 id="인자-분리-1"><a class="docs-heading-anchor" href="#인자-분리-1">인자 분리</a><a class="docs-heading-anchor-permalink" href="#인자-분리-1" title="Permalink"></a></h2><p>The destructuring feature can also be used within a function argument. If a function argument name is written as a tuple (e.g. <code>(x, y)</code>) instead of just a symbol, then an assignment <code>(x, y) = argument</code> will be inserted for you:</p><pre><code class="language-julia">julia&gt; minmax(x, y) = (y &lt; x) ? (y, x) : (x, y)

julia&gt; range((min, max)) = max - min

julia&gt; range(minmax(10, 2))
8</code></pre><p>Notice the extra set of parentheses in the definition of <code>range</code>. Without those, <code>range</code> would be a two-argument function, and this example would not work.</p><h2 id="가변인자-함수-1"><a class="docs-heading-anchor" href="#가변인자-함수-1">가변인자 함수</a><a class="docs-heading-anchor-permalink" href="#가변인자-함수-1" title="Permalink"></a></h2><p>경우에 따라 함수에 원하는 만큼 인자를 주는 것이 유용할 때도 있다. 이러한 가변인자 함수를 만들려면 함수 인자 선언의 마지막에 <code>(인자 이름)...</code>을 넣으면 된다:</p><pre><code class="language-julia-repl">julia&gt; bar(a,b,x...) = (a,b,x)
bar (generic function with 1 method)</code></pre><p>위 예제에서 처음 두번째 인자까지는 <code>a</code>와 <code>b</code>에 할당되고, 변수 <code>x</code>에는 나머지 인자들이 튜플로 묶여서 전달된다:</p><pre><code class="language-julia-repl">julia&gt; bar(1,2)
(1, 2, ())

julia&gt; bar(1,2,3)
(1, 2, (3,))

julia&gt; bar(1, 2, 3, 4)
(1, 2, (3, 4))

julia&gt; bar(1,2,3,4,5,6)
(1, 2, (3, 4, 5, 6))</code></pre><p>가변인자의 개수를 제한하는 방법은 <a href="manual/@ref">매개변수적으로 제한된 Varargs 메서드</a>에서 확인할 수 있다.</p><p><code>...</code>을 다르게도 활용할 수 있다. interable 객체에 저장된 값 하나하나를 전부 함수 인자로 주고 싶을 때, 해당 변수에 <code>...</code>을 붙여주면 순서대로 인자를 넣어준다. 아래의 경우 튜플이 알아서 쪼개져 각 인자에 순서대로 들어간다:</p><pre><code class="language-julia-repl">julia&gt; x = (3, 4)
(3, 4)

julia&gt; bar(1,2,x...)
(1, 2, (3, 4))

julia&gt; x = (2, 3, 4)
(2, 3, 4)

julia&gt; bar(1,x...)
(1, 2, (3, 4))

julia&gt; x = (1, 2, 3, 4)
(1, 2, 3, 4)

julia&gt; bar(x...)
(1, 2, (3, 4))</code></pre><p>물론 interable 객체이기만 하면 위 방법을 사용할 수 있다:</p><pre><code class="language-julia-repl">julia&gt; x = [3,4]
2-element Array{Int64,1}:
 3
 4

julia&gt; bar(1,2,x...)
(1, 2, (3, 4))

julia&gt; x = [1,2,3,4]
4-element Array{Int64,1}:
 1
 2
 3
 4

julia&gt; bar(x...)
(1, 2, (3, 4))</code></pre><p>이 방법은 가변인자 함수가 아니어도 사용할 수 있다:</p><pre><code class="language-julia-repl">julia&gt; baz(a,b) = a + b;

julia&gt; args = [1,2]
2-element Array{Int64,1}:
 1
 2

julia&gt; baz(args...)
3

julia&gt; args = [1,2,3]
3-element Array{Int64,1}:
 1
 2
 3

julia&gt; baz(args...)
ERROR: MethodError: no method matching baz(::Int64, ::Int64, ::Int64)
Closest candidates are:
  baz(::Any, ::Any) at none:1</code></pre><p>보다시피 인자의 개수가 잘못되면 함수 호출은 실패하고 위와 같은 에러를 보게 될 것이다.</p><h2 id="기본값이-제공된-인자(optional-arguments)-1"><a class="docs-heading-anchor" href="#기본값이-제공된-인자(optional-arguments)-1">기본값이 제공된 인자(optional arguments)</a><a class="docs-heading-anchor-permalink" href="#기본값이-제공된-인자(optional-arguments)-1" title="Permalink"></a></h2><p>기본값이 지정된 함수는 해당 인자를 주지 않아도 잘 작동한다. 예를 들어<code>Dates</code>의 <code>Date</code>타입에 지정된 <a href="../../stdlib/Dates/#Dates.Date"><code>Date(y, [m, d])</code></a> 함수는 <code>y</code>만 지정하면 <code>m</code>과 <code>d</code>는 1로 자동 지정된다:</p><pre><code class="language-julia">function Date(y::Int64, m::Int64=1, d::Int64=1)
    err = validargs(Date, y, m, d)
    err === nothing || throw(err)
    return Date(UTD(totaldays(y, m, d)))
end</code></pre><p>이 예제에 부연설명을 하면, <code>Date</code>함수는 <code>UTInstant{Day}</code>라는 인자를 받는 다른 매서드 함수 <code>Date</code>를 호출한다. 위 함수의 정의에 따라 이 함수에는 인자를 하나, 둘, 혹은 세개를 줄 수 있으며, 인자가 직접 주어지지 않을 경우 <code>1</code>이 자동으로 부여됨을 알 수 있다:</p><pre><code class="language-julia-repl">julia&gt; using Dates

julia&gt; Date(2000, 12, 12)
2000-12-12

julia&gt; Date(2000, 12)
2000-12-01

julia&gt; Date(2000)
2000-01-01</code></pre><p>기본값 제공은 다중인자 함수의 사용 편의성을 위한 것이다(<a href="../methods/#Note-on-Optional-and-keyword-Arguments-1">Note on Optional and keyword Arguments</a>를 보자). 위 예제에서 메서드 함수를 호출한 것을 보면 알 수 있다.</p><h2 id="Keyword-Arguments-1"><a class="docs-heading-anchor" href="#Keyword-Arguments-1">Keyword Arguments</a><a class="docs-heading-anchor-permalink" href="#Keyword-Arguments-1" title="Permalink"></a></h2><p>Some functions need a large number of arguments, or have a large number of behaviors. Remembering how to call such functions can be difficult. Keyword arguments can make these complex interfaces easier to use and extend by allowing arguments to be identified by name instead of only by position.</p><p>For example, consider a function <code>plot</code> that plots a line. This function might have many options, for controlling line style, width, color, and so on. If it accepts keyword arguments, a possible call might look like <code>plot(x, y, width=2)</code>, where we have chosen to specify only line width. Notice that this serves two purposes. The call is easier to read, since we can label an argument with its meaning. It also becomes possible to pass any subset of a large number of arguments, in any order.</p><p>Functions with keyword arguments are defined using a semicolon in the signature:</p><pre><code class="language-julia">function plot(x, y; style=&quot;solid&quot;, width=1, color=&quot;black&quot;)
    ###
end</code></pre><p>When the function is called, the semicolon is optional: one can either call <code>plot(x, y, width=2)</code> or <code>plot(x, y; width=2)</code>, but the former style is more common. An explicit semicolon is required only for passing varargs or computed keywords as described below.</p><p>Keyword argument default values are evaluated only when necessary (when a corresponding keyword argument is not passed), and in left-to-right order. Therefore default expressions may refer to prior keyword arguments.</p><p>The types of keyword arguments can be made explicit as follows:</p><pre><code class="language-julia">function f(;x::Int=1)
    ###
end</code></pre><p>Extra keyword arguments can be collected using <code>...</code>, as in varargs functions:</p><pre><code class="language-julia">function f(x; y=0, kwargs...)
    ###
end</code></pre><p>Inside <code>f</code>, <code>kwargs</code> will be a key-value iterator over a named tuple. Named tuples (as well as dictionaries with keys of <code>Symbol</code>) can be passed as keyword arguments using a semicolon in a call, e.g. <code>f(x, z=1; kwargs...)</code>.</p><p>If a keyword argument is not assigned a default value in the method definition, then it is <em>required</em>: an <a href="../../base/base/#Core.UndefKeywordError"><code>UndefKeywordError</code></a> exception will be thrown if the caller does not assign it a value:</p><pre><code class="language-julia">function f(x; y)
    ###
end
f(3, y=5) # ok, y is assigned
f(3)      # throws UndefKeywordError(:y)</code></pre><p>One can also pass <code>key =&gt; value</code> expressions after a semicolon. For example, <code>plot(x, y; :width =&gt; 2)</code> is equivalent to <code>plot(x, y, width=2)</code>. This is useful in situations where the keyword name is computed at runtime.</p><p>The nature of keyword arguments makes it possible to specify the same argument more than once. For example, in the call <code>plot(x, y; options..., width=2)</code> it is possible that the <code>options</code> structure also contains a value for <code>width</code>. In such a case the rightmost occurrence takes precedence; in this example, <code>width</code> is certain to have the value <code>2</code>. However, explicitly specifying the same keyword argument multiple times, for example <code>plot(x, y, width=2, width=3)</code>, is not allowed and results in a syntax error.</p><h2 id="Evaluation-Scope-of-Default-Values-1"><a class="docs-heading-anchor" href="#Evaluation-Scope-of-Default-Values-1">Evaluation Scope of Default Values</a><a class="docs-heading-anchor-permalink" href="#Evaluation-Scope-of-Default-Values-1" title="Permalink"></a></h2><p>When optional and keyword argument default expressions are evaluated, only <em>previous</em> arguments are in scope. For example, given this definition:</p><pre><code class="language-julia">function f(x, a=b, b=1)
    ###
end</code></pre><p>the <code>b</code> in <code>a=b</code> refers to a <code>b</code> in an outer scope, not the subsequent argument <code>b</code>.</p><h2 id="Do-Block-Syntax-for-Function-Arguments-1"><a class="docs-heading-anchor" href="#Do-Block-Syntax-for-Function-Arguments-1">Do-Block Syntax for Function Arguments</a><a class="docs-heading-anchor-permalink" href="#Do-Block-Syntax-for-Function-Arguments-1" title="Permalink"></a></h2><p>Passing functions as arguments to other functions is a powerful technique, but the syntax for it is not always convenient. Such calls are especially awkward to write when the function argument requires multiple lines. As an example, consider calling <a href="../../base/collections/#Base.map"><code>map</code></a> on a function with several cases:</p><pre><code class="language-julia">map(x-&gt;begin
           if x &lt; 0 &amp;&amp; iseven(x)
               return 0
           elseif x == 0
               return 1
           else
               return x
           end
       end,
    [A, B, C])</code></pre><p>Julia provides a reserved word <code>do</code> for rewriting this code more clearly:</p><pre><code class="language-julia">map([A, B, C]) do x
    if x &lt; 0 &amp;&amp; iseven(x)
        return 0
    elseif x == 0
        return 1
    else
        return x
    end
end</code></pre><p>The <code>do x</code> syntax creates an anonymous function with argument <code>x</code> and passes it as the first argument to <a href="../../base/collections/#Base.map"><code>map</code></a>. Similarly, <code>do a,b</code> would create a two-argument anonymous function, and a plain <code>do</code> would declare that what follows is an anonymous function of the form <code>() -&gt; ...</code>.</p><p>How these arguments are initialized depends on the &quot;outer&quot; function; here, <a href="../../base/collections/#Base.map"><code>map</code></a> will sequentially set <code>x</code> to <code>A</code>, <code>B</code>, <code>C</code>, calling the anonymous function on each, just as would happen in the syntax <code>map(func, [A, B, C])</code>.</p><p>This syntax makes it easier to use functions to effectively extend the language, since calls look like normal code blocks. There are many possible uses quite different from <a href="../../base/collections/#Base.map"><code>map</code></a>, such as managing system state. For example, there is a version of <a href="../../base/io-network/#Base.open"><code>open</code></a> that runs code ensuring that the opened file is eventually closed:</p><pre><code class="language-julia">open(&quot;outfile&quot;, &quot;w&quot;) do io
    write(io, data)
end</code></pre><p>This is accomplished by the following definition:</p><pre><code class="language-julia">function open(f::Function, args...)
    io = open(args...)
    try
        f(io)
    finally
        close(io)
    end
end</code></pre><p>Here, <a href="../../base/io-network/#Base.open"><code>open</code></a> first opens the file for writing and then passes the resulting output stream to the anonymous function you defined in the <code>do ... end</code> block. After your function exits, <a href="../../base/io-network/#Base.open"><code>open</code></a> will make sure that the stream is properly closed, regardless of whether your function exited normally or threw an exception. (The <code>try/finally</code> construct will be described in <a href="../control-flow/#제어-흐름-1">제어 흐름</a>.)</p><p>With the <code>do</code> block syntax, it helps to check the documentation or implementation to know how the arguments of the user function are initialized.</p><p>A <code>do</code> block, like any other inner function, can &quot;capture&quot; variables from its enclosing scope. For example, the variable <code>data</code> in the above example of <code>open...do</code> is captured from the outer scope. Captured variables can create performance challenges as discussed in <a href="../performance-tips/#man-performance-tips-1">performance tips</a>.</p><h2 id="Function-composition-and-piping-1"><a class="docs-heading-anchor" href="#Function-composition-and-piping-1">Function composition and piping</a><a class="docs-heading-anchor-permalink" href="#Function-composition-and-piping-1" title="Permalink"></a></h2><p>Functions in Julia can be combined by composing or piping (chaining) them together.</p><p>Function composition is when you combine functions together and apply the resulting composition to arguments. You use the function composition operator (<code>∘</code>) to compose the functions, so <code>(f ∘ g)(args...)</code> is the same as <code>f(g(args...))</code>.</p><p>You can type the composition operator at the REPL and suitably-configured editors using <code>\circ&lt;tab&gt;</code>.</p><p>For example, the <code>sqrt</code> and <code>+</code> functions can be composed like this:</p><pre><code class="language-julia-repl">julia&gt; (sqrt ∘ +)(3, 6)
3.0</code></pre><p>This adds the numbers first, then finds the square root of the result.</p><p>The next example composes three functions and maps the result over an array of strings:</p><pre><code class="language-julia-repl">julia&gt; map(first ∘ reverse ∘ uppercase, split(&quot;you can compose functions like this&quot;))
6-element Array{Char,1}:
 &#39;U&#39;
 &#39;N&#39;
 &#39;E&#39;
 &#39;S&#39;
 &#39;E&#39;
 &#39;S&#39;</code></pre><p>Function chaining (sometimes called &quot;piping&quot; or &quot;using a pipe&quot; to send data to a subsequent function) is when you apply a function to the previous function&#39;s output:</p><pre><code class="language-julia-repl">julia&gt; 1:10 |&gt; sum |&gt; sqrt
7.416198487095663</code></pre><p>Here, the total produced by <code>sum</code> is passed to the <code>sqrt</code> function. The equivalent composition would be:</p><pre><code class="language-julia-repl">julia&gt; (sqrt ∘ sum)(1:10)
7.416198487095663</code></pre><p>The pipe operator can also be used with broadcasting, as <code>.|&gt;</code>, to provide a useful combination of the chaining/piping and dot vectorization syntax (described next).</p><pre><code class="language-julia-repl">julia&gt; [&quot;a&quot;, &quot;list&quot;, &quot;of&quot;, &quot;strings&quot;] .|&gt; [uppercase, reverse, titlecase, length]
4-element Array{Any,1}:
  &quot;A&quot;
  &quot;tsil&quot;
  &quot;Of&quot;
 7</code></pre><h2 id="man-vectorized-1"><a class="docs-heading-anchor" href="#man-vectorized-1">배열에서 사용하는 Dot 문법</a><a class="docs-heading-anchor-permalink" href="#man-vectorized-1" title="Permalink"></a></h2><p>수치 계산용 언어에서는 함수의 스칼라 버전이 존재하면 벡터 버전이 자동 지원되는 것은 흔하다. 즉 <code>f(x)</code>가 있으면 이를 행렬의 모든 원소에 적용하는 <code>f(A)</code>가 지원되기 마련이다. 이런 문법은 데이터 처리를 편리하게 하지만, 몇몇 언어는 성능면에서 문제를 겪어 사용자가 직접 저급 언어의 라이브러리를 사용해 벡터 버전의 함수를 만들기도 한다. Julia는 성능 향상을 위해 이런 노력을 할 필요가 없다. 모든 Julia 함수 <code>f</code>는 <code>f.(A)</code>이란 문법을 사용해 원소별 연산이 가능하다. 예를 들어 <code>sin</code>로 벡터 <code>A</code>를 쉽게 계산할 수 있다:</p><pre><code class="language-julia-repl">julia&gt; A = [1.0, 2.0, 3.0]
3-element Array{Float64,1}:
 1.0
 2.0
 3.0

julia&gt; sin.(A)
3-element Array{Float64,1}:
 0.8414709848078965
 0.9092974268256817
 0.1411200080598672</code></pre><p>물론 사용자가  <code>f(A::AbstractArray) = map(f, A)</code>와 같이 직접 벡터 함수를 만드는 것도 가능하고 <code>f.(A)</code>만큼 효율적이다.</p><p>More generally, <code>f.(args...)</code> is actually equivalent to <code>broadcast(f, args...)</code>, which allows you to operate on multiple arrays (even of different shapes), or a mix of arrays and scalars (see <a href="../arrays/#Broadcasting-1">Broadcasting</a>). For example, if you have <code>f(x,y) = 3x + 4y</code>, then <code>f.(pi,A)</code> will return a new array consisting of <code>f(pi,a)</code> for each <code>a</code> in <code>A</code>, and <code>f.(vector1,vector2)</code> will return a new vector consisting of <code>f(vector1[i],vector2[i])</code> for each index <code>i</code> (throwing an exception if the vectors have different length).</p><pre><code class="language-julia-repl">julia&gt; f(x,y) = 3x + 4y;

julia&gt; A = [1.0, 2.0, 3.0];

julia&gt; B = [4.0, 5.0, 6.0];

julia&gt; f.(pi, A)
3-element Array{Float64,1}:
 13.42477796076938
 17.42477796076938
 21.42477796076938

julia&gt; f.(A, B)
3-element Array{Float64,1}:
 19.0
 26.0
 33.0</code></pre><p>Moreover, <em>nested</em> <code>f.(args...)</code> calls are <em>fused</em> into a single <code>broadcast</code> loop. For example, <code>sin.(cos.(X))</code> is equivalent to <code>broadcast(x -&gt; sin(cos(x)), X)</code>, similar to <code>[sin(cos(x)) for x in X]</code>: there is only a single loop over <code>X</code>, and a single array is allocated for the result. [In contrast, <code>sin(cos(X))</code> in a typical &quot;vectorized&quot; language would first allocate one temporary array for <code>tmp=cos(X)</code>, and then compute <code>sin(tmp)</code> in a separate loop, allocating a second array.] This loop fusion is not a compiler optimization that may or may not occur, it is a <em>syntactic guarantee</em> whenever nested <code>f.(args...)</code> calls are encountered. Technically, the fusion stops as soon as a &quot;non-dot&quot; function call is encountered; for example, in <code>sin.(sort(cos.(X)))</code> the <code>sin</code> and <code>cos</code> loops cannot be merged because of the intervening <code>sort</code> function.</p><p>Finally, the maximum efficiency is typically achieved when the output array of a vectorized operation is <em>pre-allocated</em>, so that repeated calls do not allocate new arrays over and over again for the results (see <a href="../performance-tips/#Pre-allocating-outputs-1">Pre-allocating outputs</a>). A convenient syntax for this is <code>X .= ...</code>, which is equivalent to <code>broadcast!(identity, X, ...)</code> except that, as above, the <code>broadcast!</code> loop is fused with any nested &quot;dot&quot; calls. For example, <code>X .= sin.(Y)</code> is equivalent to <code>broadcast!(sin, X, Y)</code>, overwriting <code>X</code> with <code>sin.(Y)</code> in-place. If the left-hand side is an array-indexing expression, e.g. <code>X[2:end] .= sin.(Y)</code>, then it translates to <code>broadcast!</code> on a <code>view</code>, e.g. <code>broadcast!(sin, view(X, 2:lastindex(X)), Y)</code>, so that the left-hand side is updated in-place.</p><p>Since adding dots to many operations and function calls in an expression can be tedious and lead to code that is difficult to read, the macro <a href="../../base/arrays/#Base.Broadcast.@__dot__"><code>@.</code></a> is provided to convert <em>every</em> function call, operation, and assignment in an expression into the &quot;dotted&quot; version.</p><pre><code class="language-julia-repl">julia&gt; Y = [1.0, 2.0, 3.0, 4.0];

julia&gt; X = similar(Y); # pre-allocate output array

julia&gt; @. X = sin(cos(Y)) # equivalent to X .= sin.(cos.(Y))
4-element Array{Float64,1}:
  0.5143952585235492
 -0.4042391538522658
 -0.8360218615377305
 -0.6080830096407656</code></pre><p>Binary (or unary) operators like <code>.+</code> are handled with the same mechanism: they are equivalent to <code>broadcast</code> calls and are fused with other nested &quot;dot&quot; calls.  <code>X .+= Y</code> etcetera is equivalent to <code>X .= X .+ Y</code> and results in a fused in-place assignment;  see also <a href="../mathematical-operations/#man-dot-operators-1">dot operators</a>.</p><p>You can also combine dot operations with function chaining using <a href="../../base/base/#Base.:|&gt;"><code>|&gt;</code></a>, as in this example:</p><pre><code class="language-julia-repl">julia&gt; [1:5;] .|&gt; [x-&gt;x^2, inv, x-&gt;2*x, -, isodd]
5-element Array{Real,1}:
    1
    0.5
    6
   -4
 true</code></pre><h2 id="Further-Reading-1"><a class="docs-heading-anchor" href="#Further-Reading-1">Further Reading</a><a class="docs-heading-anchor-permalink" href="#Further-Reading-1" title="Permalink"></a></h2><p>We should mention here that this is far from a complete picture of defining functions. Julia has a sophisticated type system and allows multiple dispatch on argument types. None of the examples given here provide any type annotations on their arguments, meaning that they are applicable to all types of arguments. The type system is described in <a href="../types/#man-types-1">Types</a> and defining a function in terms of methods chosen by multiple dispatch on run-time argument types is described in <a href="../methods/#Methods-1">Methods</a>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../strings/">« Strings</a><a class="docs-footer-nextpage" href="../control-flow/">제어 흐름 »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 16 February 2021 17:50">Tuesday 16 February 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
