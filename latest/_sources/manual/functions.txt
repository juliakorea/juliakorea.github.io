.. _man-functions:

.. currentmodule:: Base

***********
 함수
***********

Julia에서는 함수라는 것은 매개변수 값 튜플(tuple)과 리턴값을 
매핑하는 객체(object) 이다. Julia 함수들은 순수한 수학 함수들이 아니라, 
프로그램의 전체적인 상태를 변경하거나 혹은 그 상태에 영향을 받기도 할 수 있다는 
관점에서 보아야 한다. Julia에서의 함수를 정의하는 기본적인 문법은 다음과 같다:

.. testcode::

    function f(x,y)
      x + y
    end

.. testoutput::
    :hide:

    f (generic function with 1 method)

Julia에는 이 뿐만 아니라 함수를 정의하는 더 간결한 문법도 존재한다.
다음의 컴팩트한 "대입 형태"의 문법은 위에서 언급한 전통적인 함수 선언 문법과
동일하다::

    f(x,y) = x + y

대입 형태에서는, 엮은 표현식 (:ref:`man-compound-expressions` 참고) 이어도
함수 본체는 반드시 한 줄의 표현식이어야 한다.
간단히 말해서, 간략한 함수 정의 방식은 Julia에서 흔한 방식이다.
이 간략한 함수 문법은 키보드 타이핑과 시각적인 어지러움을 감소시켜주는 방법으로
관용적으로 널리 쓰이고 있다.

함수 호출은 전통적인 괄호 형식의 문법을 사용한다:

.. doctest::

    julia> f(2,3)
    5

괄호가 없으면, ``f``\ 라는 표현식은 함수 객체 자체를 가리키며, 
이는 다른 값들처럼 전달될 수 있다:

.. doctest::

    julia> g = f;

    julia> g(2,3)
    5

변수처럼, 함수 이름에 유니코드를 사용할 수 있다:

.. doctest::

    julia> ∑(x,y) = x + y
    ∑ (generic function with 1 method)

매개변수 전달 매커니즘
-------------------------

Julia의 함수 매개변수는 "공유에 의한 전달"\ 이라고 불리우는 방식을 따른다.
"공유에 의한 전달" 방식은 매개변수가 함수에 전달될 때 복사되지 않는다.
함수의 매개변수 그 자신들은 새로운 변수의 *바인딩*\ (값을 가리키는 새로운 주소)으로 
작동하지만, 바인딩이 가리키는 값은 함수의 매개변수로 전달되는 값과 동일하다.
하지만 함수 내부에서 수정되는 가변적인 값들은(배열과 같은) 다른 주소임에도 불구하고
함수 외부에서도 그 결과가 반영된다. 이는 Scheme, 대부분의 Lisp, Python, Ruby
그리고 Perl과 같은 다른 동적 언어에서와 같은 방식이다.

.. _man-return-keyword:

``return`` 키워드
----------------------

함수로 부터 반환되는 값은 기본적으로 함수 본문에 있는 가장 마지막 표현식의
결과값이다. 앞에서 예로 든 ``f`` 라는 예제함수를 보면 ``x + y``\ 가 
반환되는 표현식이라는 것을 알 수 있다. C와 같은 명령형 기반 혹은
다른 함수형 언어에서와 같이, Julia에서 ``return``\ 이라는 키워드는 
함수가 ``return`` 과 함께 병기된 표현식을 바로 리턴하도록 하고 있다::

    function g(x,y)
      return x * y
      x + y
    end

대화형 실행환경에서도 함수 정의 문법을 사용할 수 있기 때문에, 
위에서 언급한 다양한 정의들을 쉽게 비교해볼 수 있다::

    f(x,y) = x + y

    function g(x,y)
      return x * y
      x + y
    end

    julia> f(2,3)
    5

    julia> g(2,3)
    6

물론, ``g``\ 와 같이 순수하게 직관적인 함수 본문을 가지고 있을 때에는 
``return``\ 은 무의미한 것이 ``x + y``\ 는 절대 계산될 일이 없고, 
``x * y``\ 를 ``return``\ 을 뺀 상태로 맨 마지막 표현식으로 두어도 
무방하기 때문이다. 그러나, 다른 제어 흐름 구문과 ``return``\ 의 혼용은 
실제로 의미가 있는 조합이다. 예를 들어, *x*\ 와 *y*\ 를 밑변과 높이로 하는 
직각 삼각형의 빗변의 길이를 구하는 함수에서는 오버플로우(overflow)를 
피하기 위해 ``return``\ 이 유의미하게 쓰일 수 있다::

    function hypot(x,y)
      x = abs(x)
      y = abs(y)
      if x > y
        r = y/x
        return x*sqrt(1+r*r)
      end
      if y == 0
        return zero(x)
      end
      r = x/y
      return y*sqrt(1+r*r)
    end

이 함수에는 *x*\ 와 *y*\ 의 값에 따라 결정되는 세 종류의 다른 표현식 때문에 
세 지점의 리턴 지점이 존재한다. 마지막 줄의 ``return``\ 은 이 함수 본문의 
마지막 표현식이기 때문에 생략 가능하다.

연산자 또한 함수
-----------------------

Julia에서는, 대부분의 연산자들은 일반적인 함수들과 다를 바 없다. 
다만 특별한 문법이 연산자를 뒷받침하고 있다.
(이것에 대한 예외는 ``&&``\ 나 ``||``\ 와 같이 특별한 계산 방식을 지니고 있는 
연산자들이다. :ref:`short-circuit evaluation <man-short-circuit-evaluation>`\ 에서
알 수 있듯이 ``&&``\ 나 ``||``\ 와 같은 연산자들은 연산자들의 계산 이전에 
피연산자들이 먼저 계산될 수 없기 때문에 함수로 쓸 수 없다.)
따라서, 대부분의 연산자들은 다른 함수들과 마찬가지로 
괄호와 매개변수를 이용한 형식으로 쓸 수 있다:

.. doctest::

    julia> 1 + 2 + 3
    6

    julia> +(1,2,3)
    6

중위 표현법(infix form)은 함수형 표기법과 동일하다. 
— 실은 중위 표현법도 내부적으로는 함수를 불러오는 형태로 파싱된다. 
이것은 :func:`+`\ 와 :func:`*`\ 와 같은 연산자들을 다른 함수값들과 같이 
변수처럼 대입하고 전달할 수 있다는 이야기가 된다:

.. doctest:: f-plus

    julia> f = +;

    julia> f(1,2,3)
    6

그러나 ``f``\ 라는 이름은 중위표현법을 지원하지 않는다.

특별한 이름을 지니고 있는 연산자
---------------------------------

다음은 몇 가지 표현식들이 Julia 내부에서 
특정한 이름을 가지고 있는 함수로 매핑된다는 것을 나열한 것이다:

=================== ==================
표현식              함수 이름
=================== ==================
``[A B C ...]``     :func:`hcat`
``[A, B, C, ...]``  :func:`vcat`
``[A B; C D; ...]`` :func:`hvcat`
``A'``              :func:`ctranspose`
``A.'``             :func:`transpose`
``1:n``             :func:`colon`
``A[i]``            :func:`getindex`
``A[i]=x``          :func:`setindex!`
=================== ==================

이 함수들은 연산자같지 않은 이름을 지니고 있지만, 
``Base.Operators`` 모듈에 포함되어 있다.

.. _man-anonymous-functions:

익명 함수
-------------------

Julia에서 함수는 일급 객체 혹은 일급 시민(`first-class objects
<https://en.wikipedia.org/wiki/First-class_citizen>`_) 이다: 
함수는 변수에 대입될 수도 있고, 대입된 변수도 일반적인 함수 호출을 사용해서 
호출할 수도 있다. 또 매개변수로도 사용될수도 있으면서도 어떤 값의 형태로 리턴될 수 있다.
함수는 정해진 이름이 없이 익명으로 생성될 수 있는데 이 때 다음과 같은 문법을 사용한다:

.. doctest::

    julia> x -> x^2 + 2x - 1
    (::#1) (generic function with 1 method)

    julia> function (x)
               x^2 + 2x - 1
           end
    (::#3) (generic function with 1 method)

이 구문은 *x*\ 이라는 매개변수 하나를 받고 ``*x*\ ^2 + 2\ *x* - 1``\ 의 
계산값을 반환하는 함수이다. 이 구문의 결과는 
제너릭 함수(generic function)지만, 
컴파일러가 순차적인 순번을 매긴 제너릭 함수라는 것을 알아두더야 할 필요가 있다.

익명함수의 주요 사용용도는 다른 함수의 매개변수로 넘겨지는 것이다. 
전통적인 예시는 :func:`map`\ 를 들 수 있는데, 
:func:`map`\ 은 배열의 각각의 값에 함수를 적용하여 결과를 새로운 배열로 반환한다:

.. doctest::

    julia> map(round, [1.2,3.5,1.7])
    3-element Array{Float64,1}:
     1.0
     4.0
     2.0

이름이 있으면서 이미 존재하는 함수를 :func:`map`\ 의 매개변수로 넘기는 것도 상관없다. 
그러나, 그렇게 준비된 이름이 있는 함수가 있는 일은 흔하지 않다. 
이런 상황에서는 익명함수는 이름이 필요없으면서 단일 사용의 목적으로 
함수를 쉽게 만들기 좋게 해준다:

.. doctest::

    julia> map(x -> x^2 + 2x - 1, [1,3,-1])
    3-element Array{Int64,1}:
      2
     14
     -2

여러 개의 매개변수를 받는 익명함수는 ``(x,y,z)->2x+y-z``\ 와 같은 문법을 사용한다. 
매개변수가 하나도 존재 하지 않는 경우에는 ``()->3``\ 을 사용한다. 
매개변수가 없는 함수라는 아이디어는 이상해보일 수도 있지만, 연산을 "늦출 때" 유용하다. 
매개변수가 없는 익명 함수 안의 코드는 나중에 ``f()``\ 라고 호출될 때 
그제서야 실행된다.

다수의 리턴값
----------------------

Julia에서는 다수의 리턴값을 흉내내기 위해 리턴할 때 값들의 튜플(tuple)로 반환한다. 
그러나, 튜플은 괄호 없이도 생성될 수도 있고 파괴될수도 있기에, 
하나의 튜플값이 아니라 여러 개의 값들이 반환된다는 환상을 심어줄 수 있다. 
예를 들어 다음 함수는 한 쌍의 값을 반환한다:

.. doctest::

    julia> function foo(a,b)
             a+b, a*b
           end;

만약 대화형 실행환경에서 함수의 결과를 다른 곳에 대입하지 않고 함수를 호출한다면, 
튜플이 리턴된다는 것을 알 수 있다:

.. doctest::

    julia> foo(2,3)
    (5,6)

하지만 저런 쌍으로 이루어진 리턴값들은 
각각의 값들을 변수에 대입하는 방법으로 주로 사용한다. 
Julia는 이를 쉽게 하기 위해 간단한 방법의 튜플 "파괴" 방법을 제공한다:

.. doctest::

    julia> x, y = foo(2,3);

    julia> x
    5

    julia> y
    6

명시적으로 ``return`` 키워드를 이용할 때에도 여러개의 값들을 반환할 수 있다::

    function foo(a,b)
      return a+b, a*b
    end

이는 앞서 정의한 ``foo``\ 와 같은 결과를 가져온다.

.. _man-varargs-functions:

가변인자 함수
-----------------

때떄로 임의의 개수의 매개변수를 받는 함수를 작성해야할 때가 있다. 
이런 함수들은 전통적으로 "가변인자" 함수라고 한다.  
Julia에서 가변인자 함수를 정의하기 위해서는 마지막 매개변수를 
생략부호(...)로 넣는다:

.. doctest::

    julia> bar(a,b,x...) = (a,b,x)
    bar (generic function with 1 method)

변수 ``a``\ 와 ``b``\ 는 평소처럼 처음 두 매개변수와 매핑되지만, 
변수 ``x``\ 는 ``bar``\ 의 처음 두 매개변수 이후에 전달되는 
0개 혹은 그 이상의 반복 가능한 컬렉션에 포함되어 있는 값과 매핑된다:

.. doctest::

    julia> bar(1,2)
    (1,2,())

    julia> bar(1,2,3)
    (1,2,(3,))

    julia> bar(1,2,3,4)
    (1,2,(3,4))

    julia> bar(1,2,3,4,5,6)
    (1,2,(3,4,5,6))

이 모든 경우에 대해, ``x``\ 는 ``bar``\ 에 전달되는 뒷부분의 튜플에 매핑된다.

가변인수의 갯수도 통제 가능하다.
이는 :ref:`man-vararg-fixedlen`\ 에서 나중에 다룰 예정이다.

위와 반대로, 어떤 때는 반복가능한 컬렉션 안에 있는 값들을 
함수 호출 시 각각의 매개변수와 결합시켜서 대응하는 것(splice)이 유용할 때가 있다. 
이를 위해서는 ``...``\ 을 함수 정의가 아닌 함수 호출 시에 사용하도록 한다:

.. doctest::

    julia> x = (3,4)
    (3,4)

    julia> bar(1,2,x...)
    (1,2,(3,4))

위 경우에는 튜플이 가변 인자의 위치와 정확하게 대응되어 결합한다. 
하지만, 반드시 이런 경우만 있는 것은 아니다:

.. doctest::

    julia> x = (2,3,4)
    (2,3,4)

    julia> bar(1,x...)
    (1,2,(3,4))

    julia> x = (1,2,3,4)
    (1,2,3,4)

    julia> bar(x...)
    (1,2,(3,4))

게다가, 반복가능한 객체는 반드시 튜플일 필요는 없다:

.. doctest::

    julia> x = [3,4]
    2-element Array{Int64,1}:
     3
     4

    julia> bar(1,2,x...)
    (1,2,(3,4))

    julia> x = [1,2,3,4]
    4-element Array{Int64,1}:
     1
     2
     3
     4

    julia> bar(x...)
    (1,2,(3,4))

또한, 이런 매개변수 결합대응(splice)은 
꼭 가변 인자 함수에서만 적용할 수 있는 것은 아니다:

.. doctest::

    julia> baz(a,b) = a + b;

    julia> args = [1,2]
    2-element Array{Int64,1}:
     1
     2

    julia> baz(args...)
    3

    julia> args = [1,2,3]
    3-element Array{Int64,1}:
     1
     2
     3

    julia> baz(args...)
    ERROR: MethodError: no method matching baz(::Int64, ::Int64, ::Int64)
    Closest candidates are:
      baz(::Any, ::Any) at none:1
    ...

보다시피, 매개변수 결합대응 객체의 수가 실제 함수의 정의와 맞지 않으면, 
함수 호출은 실패할 것이다. 이는 일반 함수 호출에서 
명시적으로 매개변수를 너무 많이 넣어서 함수 호출이 실패하는 것과 
같은 결과이다.

선택적 매개변수
------------------

많은 경우에 있어서, 함수의 매개변수는 기본적으로 주어질 값(디폴트 값)을 가정할 수 있고,  
그에 따라 함수 호출에 있어서 매번 모든 매개변수를 넣는 것이 바람직하지 않을 수도 있다. 
예를 들어, 라이브러리 함수 :func:`parse(type,num,base) <parse>`\ 는 문자열을 
``base``\ 에 해당하는 숫자로 해석한다. 기본값으로 십진법을 가정하면, ``base``\ 는 
``10``\ 을 기본값으로 한다. 이런 경우를 간략하게 표현하면 다음과 같다::

    function parse(type, num, base=10)
        ###
    end

이런 식의 정의를 이용하면, 함수는 2개 혹은 3개의 매개변수로 호출할 수 있다. 
만약 세번째 매개변수가 지정되지 않다면 자동적으로 ``10``\ 이라는 매개변수가 
``base``\ 로 가정한 함수가 호출된다:

.. doctest::

    julia> parse(Int,"12",10)
    12

    julia> parse(Int,"12",3)
    5

    julia> parse(Int,"12")
    12

선택적 매개변수는 정확하게 말해서 다양한 수의 매개변수를 지니는 다수의 
메소드(method)를 정의하는 간편한 방법일 뿐이다.


키워드 매개변수
-----------------

어떤 함수들은 매우 많은 수의 매개변수가 필요하거나 아니면 매우 다양한 
호출이 있을 수도 있다. 이런 함수를 호출하는 것은 어렵다는 것을 기억해보자. 
키워드 매개변수는 이런 복잡한 인터페이스를 쉽게 사용할 수 있게 하고, 
위치에 따라 매개변수를 구분하는 것이 아니라 이름에 따라 구분할 수 있게 한다.

예를 들어 선형의 그래프를 그리는 ``plot``\ 이라는 함수를 가정해볼 수 있다. 
이 함수는 선의 스타일, 굵기, 색 등등을 설정할 수 있는 매우 많은 옵션을 
가질 수 있다. 만약에 이 함수가 키워드 매개변수를 받는다면, 
함수 호출 시 ``plot(x, y, width=2)``\ 처럼 선의 굵기만을 옵션으로 
지정할 수 있을 것이다. 이런 호출은 매개변수에 의미를 부여함으로써 코드를 
읽기 쉽게 만든다. 또한, 이는 순서에 상관없이 다양한 경우의 매개변수를 지니는 
함수를 호출할 수 있게 해준다.

키워드 매개변수를 가지는 함수는 일반적인 매개변수와 키워드 매개변수를 
구부하는 기호로 세미콜론을 사용한다::

    function plot(x, y; style="solid", width=1, color="black")
        ###
    end

함수가 호출될 때, 세미콜론이 반드시 필요한 것은 아니다: 
``plot(x, y, width=2)``\ 와 ``plot(x, y; width=2)`` 모두 호출 가능하다, 
그러나 ``plot(x, y, width=2)``\ 이 좀 더 널리 쓰이는 표현이다. 
그러나 앞에서 언급한 가변 인자 함수나 앞으로 설명할 계산된 키워드 매개변수의 
경우에는 세미콜론이 반드시 필요하다.

키워드 매개변수의 디폴트값은 필요할 때만 계산된다. (해당 키워드 매개변수가 
전달되지 않았을 때만 계산된다) 그리고 이는 
왼쪽에서 오른쪽으로 계산되기 때문에 디폴트값을 표현하는 표현식들은 
앞서 언급한 키워드 매개변수를 가리킬 것이다.

키워드 매개변수의 타입은 다음과 같이 명시적으로 지정할 수 있다::

    function f(;x::Int64=1)
        ###
    end

가변 인자 함수에서처럼 함수 정의에서 명시되지 않은 
추가 키워드 매개변수는 ``...``\ 을 이용해서 
전달할 수 있다::

    function f(x; y=0, kwargs...)
        ###
    end

``f``\ 안에서, ``kwargs``\ 는 ``key``\ 를 매개변수 이름으로 하는 
``(key,value)`` 튜플의 집합체이다. 이런 컬렉션들은 함수 호출에서 
세미콜론을 이용한 키워드 매개변수처럼 전달된다. 
예를 들어 ``f(x, z=1; kwargs...)`` 같이 말이다. 
딕셔너리 타입의 컬렉션들 또한 이런 목적으로 사용될 수 있다.

키워드 매개변수를 ``(key,value)`` 튜플 혹은 
튜플에 대입될 수 있는 반복가능한 표현식
(예를 들어 ``=>``\ 로 만들 수 있는 한 쌍의 값)
을 통해서도 전달할 수 있다. 다만 이 경우에는 세미콜론 이후에 전달해야한다. 
예를 들어, ``plot(x, y; (:width,2))``\ 와 ``plot(x, y; :width => 2)``\ 는 
``plot(x, y, width=2)``\ 와 동등한 표현이다. 이것은 실해중에 키워드 이름이 
결정되는 경우 유용하다. 

키워드 매개변수의 속성때분에 한 매개변수를 여러번 표시할 수 있다.
예를 들어, ``plot(x, y; options..., width=2)``\ 와 같은 함수 호출에서 
``options``\ 라는 구조체 내부에 ``width``\ 라는 값을 포함할 수 있다.
이런 경우에는 오른쪽에 있는 매개변수가 우선순위를 가진다; 
이번 예제에서는 ``width``\ 에는 ``2``\ 라는 정수가 들어간다.

.. _man-evaluation-scope-default-values:

디폴트 값의 계산 스코프(scope)
----------------------------------

선택적 매개변수와 키워드 매개변수는 기본값을 어떻게 계산하는 지에 따라 
미세한 차이를 보인다. 선택적 매개변수의 기본값 표현식이 계산될 때는 
선택적 매개변수가 명시되기 전의 *이전의* 매개변수만이 현재 스코프 안에 있을 수 있다. 
반면에, 키워드 매개변수의 경우는 *모든* 매개변수가 현재 스코프안에 있다. 
예를 들어, 다음과 같은 정의를 보면::

    function f(x, a=b, b=1)
        ###
    end

``a=b``\ 에서의 ``b``\ 는 함수 ``f``\ 의 매개변수 ``b``\ 가 아닌 
함수 바깥의 ``b``\ 를 가리킨다. 그러나, ``a``\ 와 ``b``\ 가 
키워드 매개변수였다면 ``a``\ 와 ``b`` 모두 같은 스코프에 있고 
``a=b``\ 에서의 ``b``\ 는 매개변수 ``b``\ 를 가리켰을 것이다. 
(이 경우 바깥쪽 스코프의 ``b``\ 와는 아무런 상관이 없다) 
이 경우, 위 코드는 디폴트값 표현식은 왼쪽에서 오른쪽으로 
계산되기 때문에 ``b``\ 에 어떠한 값도 지정되지 않아 
undefined variable error를 일으킨다.


함수 매개변수의 Do-Block 문법
--------------------------------------

함수를 다른 함수의 매개변수로 전달하는 것은 강력한 기술이지만, 
이에 관련한 문법은 항상 편리한 것은 아니다. 
이런 함수 호출은 특히 함수의 매개변수가 여러 줄에 걸쳐 있을 경우 
혼돈을 안겨줄 수 있다. 예를 들어, :func:`map`\ 을 여러 경우에 따라 
다르게 호출할 때를 생각해보자::

    map(x->begin
               if x < 0 && iseven(x)
                   return 0
               elseif x == 0
                   return 1
               else
                   return x
               end
           end,
        [A, B, C])

Julia는 예약어 ``do``\ 를 이용하여 위의 코드를 보다 간결할 수 있도록 한다::

    map([A, B, C]) do x
        if x < 0 && iseven(x)
            return 0
        elseif x == 0
            return 1
        else
            return x
        end
    end

``do x`` 문법은 :func:`map`\ 의 첫 번째 매개변수로 전달하는 
매개변수 ``x``\ 를 지니는 익명함수를 생성한다. 
마찬가지로, ``do a,b``\ 는 두 개의 매개변수를 받는 익명함수를 생성하고, 
``do`` 만 쓰면 ``() -> ...`` 형태를 지니는 익명함수를 선언하게 된다. 

이 매개변수들은 "바깥쪽" 함수들에 의해서 초기화된다; 
여기서 :func:`map`\ 는 순차적으로 ``x``\ 를 ``A``, ``B``, ``C``\ 로
설정하고 각각의 익명함수를 호출한다. 
이는 ``map(func, [A, B, C])``\ 라고 호출할 때 벌어지는 일들과 똑같다. 

이 문법은 함수 호출을 일반적인 코드 블럭처럼 보이게 함으로써 
언어를 효과적으로 확장하여 함수를 쉽게 쓸 수 있게 해준다. 
시스템의 상태를 관리할 때와 같이 
:func:`map`\ 의 상당히 다양한 형태를 이용하는 경우가 있다. 
예를 들어, 함수가 끝날 때 열었던 파일을 반드시 닫는 
:func:`open`\ 의 또 다른 버전이 있다고 하자::

    open("outfile", "w") do io
        write(io, data)
    end

:func:`open`\ 은 다음과 같이 정의되었다:: 

    function open(f::Function, args...)
        io = open(args...)
        try
            f(io)
        finally
            close(io)
        end
    end

여기서 :func:`open`\ 는 쓰기용 파일을 먼저 열고, ``do ... end`` 블록에 
정의한 익명함수(``f``, ``do`` 블록에서는 func:`write`\ )에 
출력용 스트림을 전달한 것이다. 
함수 ``f``\ 가 종료하면, :func:`open`\ 은 
``f``\ 가 정상적으로 종료되었든 예외를 발생했든 간에 
출력용 스트림이 항상 닫히도록 한다. 
(``try/finally`` 구문은 :ref:`man-control-flow`\ 에서 설명할 예정이다.

``do`` 블록 문법은 문서나 구현이 사용자가 만든 함수의 매개변수가 
어떻게 초기화되었는지 알 수 있도록 도와주는 역할을 한다.

.. _man-dot-vectorizing:

함수의 벡터화를 위한 Dot 문법
------------------------------------

과학계산용 언어에서는 함수를 "벡터화"된 버전으로 쓰는 것이 흔한 일이다. 
예를 들어 주어진 함수 ``f(x)``\ 를 배열 ``A`` 각각의 원소에 적용하고 싶으면 
``f(A)``\ 라고 쓰듯이 말이다. 
이런 형태의 문법은 데이터 처리할 때 편리하지만, 다른 언어들에서의 "벡터화"는 
성능을 위해서 필요할 때도 있다: 만약 반복문이 느리다면, "벡터화"된 버전의 함수는 
저수준의 언어로 쓰여진 빠른 라이브러리 코드를 불러온다. 
Julia에서는 벡터화된 함수를 성능때문에 *반드시 써야할 필요는 없다.*  
그리고 이는 벡터화된 형태에 구애받지 않고 사용자만의 반복문을 마음대로 쓸 수 있게 
해 준다. (:ref:`man-performance-tips` 참고)  그러나, 여전히 벡터화는 편리한 존재이기에,
Julia로 쓰여진 아무 함수 ``f``\ 는 배열(혹은 다른 컬렉션)에 ``f.(A)``\ 라는 문법을 
이용하면 배열(혹은 다른 컬렉션)의 각 원소에 적용할 수 있다.

물론, ``f(A::AbstractArray) = map(f, A)``\ 와 같은 문법을 이용하면, 
``f``\ 라고 하는 특별히 만든 "벡터화"된 메소드를 작성할 때 점을 생략할 수 있다.
물론 이 경우는 ``f.(A)``\ 와 마찬가지로 효율적이다. 
그러나 이런 접근법은 추후 어떤 함수를 벡터화할지 일일이 결정해야할 필요가 있다.

더 일반적으로, ``f.(args...)``\ 는 여러 개의 배열(서로 다른 모양의 배열이라도), 
혹은 배열과 스칼라의 혼합된 형태끼리에도 벡터화를 적용할 수 있는 
``broadcast(f, args)``\ 와도 같다. (:ref:`man-broadcasting` 참고)
예를 들어, 만약 ``f(x,y) = 3x + 4y``\ 라고 하면, ``f.(pi.A)``\ 는 
``A``\ 의 각각의 원소 ``a``\ 에 대해 ``f(pi,a)``\ 를 적용한 새 배열이 리턴될 것이고, 
``f.(vector1,vector2)``\ 는 각각의 인덱스 ``i``\ 에 대해 
``f(vector1[i],vector2[i])``\ 로 구성된 새 벡터를 리턴할 것이다. 
(물론 두 벡터가 다른 길이면 예외를 발생시킬 것이다)

게다가, *중첩된* ``f.(args...)`` 호출은 하나의 ``broadcast`` 반복문으으로 
녹아들어갈 수 있다. 
예를 들어, ``sin.(cos.(X))``\ 는 ``broadcast(x -> sin(cos(x)), X)``\ 와 같고, 
이는 ``[sin(cos(x)) for x in X]``\ 와 같은 결과를 나타낸다. 
[반대로, 벡터화를 지원하는 일반적인 언어에서는 ``sin(cos(X))``\ 를 호출할 때 
``tmp=cos(X)``\ 를 위한 임시적인 배열을 할당하고, ``sin(tmp)``\ 를 또 다른 배열을 호출하면서 
별도의 반복문에서 처리한다.]
이런 반복문의 결합은 컴파일러의 최적화에 따라 일어날 가능성을 주는 것이 아니라, 
``f.(args...)`` 호출이 일어날 때마다 *문법상으로 100% 발생*\ 한다고 보증한다.
기술적으로 이런 결합은 "점이 아닌, 즉 벡터화가 적용되지 않는(non-dot)" 함수들이 나타나는 순간 
멈추게 되어있다. 예를 들어, ``sin.(sort(cos.(X)))``\ 에서 ``sin``\ 과 ``cos`` 반복문은 
결합될 수가 없는 것이, 중간에 ``sort`` 함수가 끼어들어갔기 때문이다.

결론적으로, 벡터화된 연산을 가장 효율적으로 활용하기 위해서
출력용 배열이 *미리 할당*\ 되어 있어야한다. 왜냐하면, 그렇지 않다면  
호출이 일어날 때마다 새 배열을 계속 할당할 것이기 때문이다. (:ref:`man-preallocation`:) 
이를 위한 편리한 문법은  ``broadcast!(identity, X, ...)``\ 와 같은 의미의 
``X .= ...``\ 가 있다. 이를 제외하고는 ``broadcast!`` 반복문은 어떠한 
"점" 호출("dot" calls)과도 융합할 수 있다.
예를 들어, ``X .= sin.(Y)``\ 는 ``broadcast!(sin, X, Y)``\ 와 같은 식인데, 이 경우 
``X``\ 를 ``sin.(Y)``\ 로 덮어쓴다. 
만약 좌변이 ``X[2:end] .= sin.(Y)``\ 와 같이 배열의 인덱스와 관련된 표현식인 경우,  
좌변의 값을 변경하기 위해, ``broadcast!(sin, view(X, 2:endof(X)), Y)``\ 와 같이 
``뷰(view)`` 관점에서 ``broadcast!``\ 로 본래의 식을  변환한다.

(미래의 Julia에서는, ``.*``\ 와 같은 연산자들은 같은 메커니즘으로 처리될 것이다: 
이들은 ``broadcast`` 호출과 같아질 것이며, 다른 중첩된 "점" 호출처럼 융합할 수 있을 것이다. 
``X .+= Y``\ 는 덮어씌워지며 융합된 결과로 ``X .= X .+ Y``\ 와 같은 값을 지니게 될 것이다. 
`` .*= `` 등에서도 같은 일이 벌어질 것이다.)

더 읽을거리
---------------

함수 정의에 대해 여기서 언급한 것 뿐만 아니라 다른 이야깃거리들이 
더 많다. Julia는 정교한 타입시스템을 가지고 있고 이는 
매개변수에 따라 멀티플 디스패치를 가능하게 해준다. 
여기에서 언급한 어떤 예제도 매개변수의 타입 어노테이션(어떠한 
타입에도 적용가능하도록 하는 것)에 대한 
예제를 언급하지 않았다. 타입 시스템은 :ref:`man-types`\ 에서 
설명할 것이고, 프로그램 실행시 결정되는 매개변수 타입에 의한 
멀티플 디스패치에 관련한 함수에 대한 설명은 :ref:`man-methods`\ 에서 
논의할 예정이다.
